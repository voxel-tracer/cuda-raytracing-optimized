---------------------------------------------------------------------------------------------------------
FEATURES
---------------------------------------------------------------------------------------------------------

 LOW POLYGON RENDERER (PHASE I)
 --------------------------
- one line summary
  apply all the optimization techniques I learned so far to produce high quality renders really quickly
  (this is the same work I've been doing for the past year but with great looking renders)
- required features
 . support low poly models that can fit in constant memory. I may simplify models to reduce their poly count
 . support a few interesting materials that produce great renders
   (tinted glass, subsurface scattering, coat)
 . basic lighting and background setup that produces great renders
 . apply all the optimizations I learned so far along with any other optimization that may improve the
   performance of the renderer (SAH BVH building, russian roulette, ...)
- optional features
 . transparent bg with invisible plane that allows you to change to color of the whole background while keeping
   the shadows and reflections on the floor

 HIGH QUALITY POLYGON RENDERER (PHASE II)
 ----------------------------------------
- one line summary
  enhance phase 1 renderer to support high quality models (sculptures) and optimize BVH construction/traversal
  to render the models as quickly as possible (ideally in real-time)
- required features
 
 PBR MATERIAL EDITOR (PHASE III)
 ------------------------------
- one line summary
  allow user to configure PBR materials and replace existing sculpture materials with those
  producing incredible renders (think CGTrader Marvel/DC Comics renders) really fast

 OTHER DELIVERABLES IN NO PARTICULAR ORDER
 -----------------------------------------
- support large polygon models
- subsurface scattering (Peter Shirley Volume rendering)
- raylib mesh viewer that supports rendering directly to the viewport
 . we can start with render goes straight to disk
 . this will be useful when building my own rendering/material tool
- integrate with Lighthouse 2
 . we get a model loader/viewer for free
 . we can compare performance of my renderer vs others
 . this is useful when I just want to focus on the render core and optimize it
- advanced materials: implement Disney BRDF and add UI to configure materials
- allow setting different material per original model color

 IMPROVEMENTS IN NO PARTICULAR ORDER
 -----------------------------------
- use MeshLab to simplify complex models so they can fit in constant memory
- when importing a model, define its orientation (up vector) and make sure its loading
  in the correct orientation. Makes it easier to use a standard camera position and orient
  the environment map
- camera distance is computed automatically such that the whole model is visible in the viewport
- transparent background (useful to create interesting renders in Gimp)
 . note that ideally we want to capture the full RGB of the background/floor as an ALPHA channel but no image format
   supports this
 . alternative is to treat background/floor differently when hit by primary ray
  . use a different color defined by the user that doesn't affect the scene
- resume rendering from saved file (useful when we want to add more samples to an already expensive render)
- can we preprocess the triangles to identify the ones that don't face any other triangle from the model ?
 . we could use this to quickly identify no_hits for secondary rays
- Gimp "White Balance" improves the quality of the final renderer
 . can I implement the same strategy in my renderer ?
---------------------------------------------------------------------------------------------------------
PHASE I.1: POLYGON RENDERER
---------------------------------------------------------------------------------------------------------
 REQUIREMENTS
 ------------
- support triangle mesh .obj models that fit in constant memory
- support a few interesting materials that produce great renderers
 . DONE tinted glass with Beer-lambert model
 . DONE existing plastic/coat (diffuse + glass)
- DONE basic lighting and background setup that produces great renderers

 DELIVERABLES
 ------------
- great looking renders that may be too slow to renderer

 TASKS
 -----
 - DONE render obj model
  . DONE load obj as triangle list
  . DONE copy triangles to constant memory
    . constant mem size = 65536B, each triangle uses 3 vec3 = 3x3x float = 3x3x4B = 36B => we can store 1280 tris
  . DONE ray-triangle intersection with a single material
- DONE floor
  . DONE use 2 triangles to represent the floor
  . DONE make it big enough to catch any shadows
  . DONE use coat material
- DONE light and next event estimation
 . DONE extend scatter() to update a hasShadow
 . DONE color() compute shadowRay if hasShadow
 . DONE hit() has a isShadow that will stop at first intersection
 . DONE color() accounts for light emissiviness if hasShadow and no shadow hit
- DONE Lambert-Beer absorption
 . DONE GLASS material (vec3 absorptionColor, float absorptionDistance)
  . absorptionCoefficient = -log(absorptionColor) / absorptionDistance
 . DONE when ray exits the model (frontFace = false), hit.t represents the distance travelled inside the model
  . compute transmission = exp(-absorptionCoefficient * hit.t)
  . attentuation *= transmission

 NOTES
 -----
- stats for tinted glass on coat w 4096spp
primary:        3.932.160.000
primary(nohit): 2.990.816.128
secondary:      3.567.756.802
shadows:        3.404.672.183
power < 0.01:   1.479.651.414

- 76% of all primary rays are nohit
 . those rays are not contributing to the final image, if we remove them we could speedup the renderer
 . this will also help for shadow rays
 . using bounding box for the whole model (excluding the floor) should help
 . we could also discard pixels when N samples didn't hit the model (only works for primary rays)
- 19% of all rays have an intensity < 1%
 . those rays aren't contributing much and we should be able to trim them
 . russian roulette should help here
 . I may need to compute RMSE with a reference image to track quality loss this introduces

 NEXT (move these to their own steps later)
 ----
- apply basic optimizations from my previous work to speedup the rendering a bit
 . we should expect very good speedup with not much effort
- add subsurface-scattering material
- add OpenGL/imGUI viewer (from my spheres renderer)
 . quickly configure the scene to get high quality renderers
- Subsurface scattering material
 . https://computergraphics.stackexchange.com/questions/5214/a-recent-approach-for-subsurface-scattering

----------------------------------------------------------------------------------------------------------
PHASE I.2 BASIC OPTIMIZATIONS
----------------------------------------------------------------------------------------------------------
- use the ray stats I collected and identify strategies to reduce total number of traced rays
- apply optimization strategies from my previous work without introducing a full BVH
- target 20x speedup => tinted on coat w 4096spp should render in < 1mn (vs +20mn now)
- do not worry about good design as we are mostly interested by the performance of the renderer
 
 DELIVERABLES
 ------------
- Fast renderer that can be extended with more expensive materials
 . Render tinted on coat w 4096spp < 1mn

 TASKS
 -----
- handle floor as proper infinite plane in kernel
 . just pass it's normal and elevation on that normal and its material
 . this will simplify handling all triangles as a single mesh
- compute bounding box for the mesh and use it to quickly discard rays
  this can provide up to 4x speedup (less most likely)
- if N samples of same pixel didn't hit the model then remaining samples should just intersect the floor
  this should bring speedup to 4x
 . start by measuring how many rays are affected by this and only work on it if it has good potential
- build a simplified grid acceleration structure
  for N^3 grid rays will at most traverse 3N => 
  N=2 => 4x
  N=4 => 5x
  N=8 => 20x
- [optional] use russian roulette to stop tracing low intensity paths
  https://computergraphics.stackexchange.com/questions/5214/a-recent-approach-for-subsurface-scattering
  user defines number of bounces before we start applying RR = RR_start_bounce
  this can provide a 20% speedup and even more considering those bounces are most likely with high divergence
 . implement RMSE to measure quality loss for various RR_start_bounce
   https://jacco.ompf2.com/2020/04/07/speeding-up-lighthouse-2/
- [optional] preprocess the triangles and identify the ones that don't face any other triangle from the mesh
 . those triangles are guaranteed to not hit anything for their shadow and scattered rays (except floor for scattered rays)
 . depends on how many triangles have this property
- use meshLab to simplify more complex models and render them

----------------------------------------------------------------------------------------------------------
